# Copyright (c) Meta Platforms, Inc. and affiliates.

schema search.code.16 {

import buck.4
import code
import code.cxx
import code.hack
import code.java
import code.python
import codemarkup.types
import csharp
import cxx1
import erlang
import fbthrift
import flow
import graphql
import hack
import hs.2
import javakotlin.alpha
import lsif
import pp1
import python
import search.cxx
import search.erlang
import search.flow
import search.hack
import search.hs
import search.java
import search.kind.cxx
import search.kotlin
import search.python

#
# public API
#

# global symbol search with language constraint
# migrate these to kind-based search so that the union of them covers each
# language once
predicate SearchByNameAndLanguage:
  {
    name: string,
    language: code.Language,
    entity: code.Entity,
  }
  { Name, Language, Entity } where
  # see SearchByNameKindAndLanguage for C++, PreProcessor, Python
    ( Hack = Language; HackSearchByName { Name, Entity } ) |
    ( JavaScript = Language; FlowSearchByName { Name, Entity } ) |
    ( Java = Language; JavaSearchByName { Name, Entity } ) |
    ( Kotlin = Language; KotlinSearchByName { Name, Entity } ) |
    ( Haskell = Language; HsSearchByName { Name, Entity } ) |
    ( Erlang = Language; ErlangSearchByName { Name, Entity } ) |
    ( Thrift = Language; ThriftSearchByName { Name, Entity } ) |
    ( Buck = Language; BuckSearchByName { Name, Entity } ) |
    ( CSharp = Language; CSharpSearchByName { Name, Entity } ) |
    ( GraphQL = Language; GraphQLSearchByName { Name, Entity } );
    code.EntityLanguage { Entity, Language }; # double check the entity lang

# global symbol search normalized to lower case
predicate SearchByLowerCaseNameAndLanguage:
  {
    name: string,
    language: code.Language,
    entity: code.Entity,
  }
  { Name, Language, Entity } where
 # See SearchByLowerCaseNameKindAndLanguage
    ( Hack = Language; HackSearchByLowerCaseName { Name, Entity } ) |
    ( JavaScript = Language; FlowSearchByLowerCaseName { Name, Entity } ) |
    ( Java = Language; JavaSearchByLowerCaseName { Name, Entity } ) |
    ( Kotlin = Language; KotlinSearchByLowerCaseName { Name, Entity } ) |
    ( Haskell = Language; HsSearchByLowerCaseName { Name, Entity } ) |
    ( Erlang = Language; ErlangSearchByLowerCaseName { Name, Entity } ) |
    ( Thrift = Language; ThriftSearchByLowerCaseName { Name, Entity } ) |
    ( Buck = Language; BuckSearchByLowerCaseName { Name, Entity } ) |
    ( CSharp = Language; CSharpSearchByLowerCaseName { Name, Entity } ) |
    ( GraphQL = Language; GraphQLSearchByLowerCaseName { Name, Entity } );
    code.EntityLanguage { Entity, Language }; # double check the entity lang

# Kind-optimized search.
predicate SearchByNameKindAndLanguage:
  {
    name: string,
    language: code.Language,
    kinds: maybe codemarkup.types.SymbolKind, # `nothing` indicates unknown kind
    entity: code.Entity
  }
  { NameStr, Language, Kinds, Entity } where
    ( Cpp = Language;
      CxxSearchByNameKindAndScopeFact { NameStr, _, Kinds, Entity }
    ) | (
      PreProcessor = Language;
      PpSearchByNameKind { NameStr, Kinds, Entity }
    ) | (
      Python = Language;
      PythonSearchByNameKindAndScopeFact { NameStr, _, Kinds, Entity }
    )

# Kind-optimized search, case insensitive.
predicate SearchByLowerCaseNameKindAndLanguage:
  {
    name: string,
    language: code.Language,
    kinds: maybe codemarkup.types.SymbolKind, # `nothing` indicates unknown kind
    entity: code.Entity
  }
  { NameStr, Language, Kinds, Entity } where
    ( Cpp = Language;
      CxxSearchByLowerCaseNameKindAndScopeFact { NameStr, _, Kinds, Entity }
    ) | (
      PreProcessor = Language;
      PpSearchByLowerCaseNameKind { NameStr, Kinds, Entity }
    ) | (
      Python = Language;
      PythonSearchByLowerCaseNameKindAndScopeFact { NameStr, _, Kinds, Entity }
    )

# scoped search

predicate SearchByScope:
  {
    name: string,
    scope: [string],
    language: code.Language,
    entity: code.Entity,
  }
  { Name, Scope, Language, Entity } where
# See SearchByScopeAndKind for C++
    ( Hack = Language; HackSearchByScope { Name, Scope, Entity } ) |
    ( JavaScript = Language; FlowSearchByScope { Name, Scope, Entity } ) |
    ( Java = Language; JavaSearchByScope { Name, Scope, Entity } ) |
    ( Kotlin = Language; KotlinSearchByScope { Name, Scope, Entity } );
    code.EntityLanguage { Entity, Language };

# lower case by scope
predicate SearchByLowerCaseScope:
  {
    name: string,
    scope: [string],
    language: code.Language,
    entity: code.Entity,
  }
  { Name, Scope, Language, Entity } where
# See SearchByLowerCaseScopeAndKind for C++
    ( Hack = Language; HackSearchByLowerCaseScope { Name, Scope, Entity } ) |
    ( Python = Language; PythonSearchByLowerCaseScope { Name, Scope, Entity }) |
    ( JavaScript = Language; FlowSearchByLowerCaseScope { Name, Scope, Entity})|
    ( Java = Language; JavaSearchByLowerCaseScope { Name, Scope, Entity}) |
    ( Kotlin = Language; KotlinSearchByLowerCaseScope { Name, Scope, Entity});
    code.EntityLanguage { Entity, Language };

# name and scope search, kind-optimized
predicate SearchByScopeAndKind:
  {
    name: string,
    scope: [string],
    language: code.Language,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity,
  }
  { Name, Scope, Language, Kinds, Entity } where
    ( Cpp = Language;
      CxxSearchByScopeAndKind { Name, Scope, Kinds, Entity };
    ) | (
      Python = Language;
      PythonSearchByScopeAndKind { Name, Scope, Kinds, Entity };
    )

# lower case by scope
predicate SearchByLowerCaseScopeAndKind:
  {
    name: string,
    scope: [string],
    language: code.Language,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity,
  }
  { Name, Scope, Language, Kinds, Entity } where
    Cpp = Language;
    CxxSearchByLowerCaseScopeAndKind { Name, Scope, Kinds, Entity }

#
# Language-specific identifier search
#

predicate HackSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    Name = hack.Name NameStr;
    HackSearchByNameWithName { Name, Entity };

predicate HackSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, Entity } where
    hack.NameLowerCase { Name, NameCase };
    HackSearchByNameWithName { NameCase, Entity };

# Helper to reuse the Name fact found previously
predicate HackSearchByNameWithName:
  {
    name : hack.Name,
    entity : code.Entity
  }
  { Name, { hack = { decl = Decl }}} where
    search.hack.SearchByName { name = Name, decl = Decl };

predicate HackSearchByScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity } where
    Name = hack.Name NameStr;
    Insensitive = false;
    HackSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate HackSearchByLowerCaseScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity} where
    hack.NameLowerCase { NameStr, Name };
    Insensitive = true;
    HackSearchByScopeWithName { Name, Insensitive, Query, Entity }

# private helper to share name facts between the calsl
#
# by always using the matched namespace we make prevent scope wildcards
# e.g. C\count won't match Test\C\count
# we could try to interpret prefix mode this way though
#
predicate HackSearchByScopeWithName:
  {
    name: hack.Name,
    insenstive : bool,
    scope: [string],
    entity: code.Entity,
  }
  { Name, Insensitive, Scope, { hack = { decl = Decl }}} where
    if ( [] = Scope; true | false = Insensitive )
      then (
        ( # exactly global declarations
          search.hack.SearchInNamespace { Name, nothing, Decl }
        ) | (
          # or global namespace alias children ("FlibSL\Vec" or "C" work)
          hack.GlobalNamespaceAlias { Name, NSQName };
          NSDecl = hack.NamespaceDeclaration { name = NSQName };
          { namespace_ = NSDecl } = Decl
        ) | (
          # or children of auto-imported namespaces (just HH for now)
          search.hack.HackInAutoImportedNamespace { Name, HHNSQName };
          search.hack.SearchInNamespace { Name, HHNSQName, Decl }
        )
      )
      else (
        # search within specific context
        search.hack.QueryToScopeCase { Scope, Insensitive, ScopeName, ScopeNamespace };
        search.hack.SearchInContext { Name, ScopeName, ScopeNamespace, Decl }
      );

predicate PythonSearchByScopeAndKind:
  {
    name: string,
    scope: [string],
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity,
  }
  { NameStr, Scope, Kinds, Entity } where
    Insensitive = false;
    search.python.QueryToScopeCase { Scope, Insensitive, MSName };
    PythonSearchByNameKindAndScopeFact { NameStr, MSName, Kinds, Entity }

predicate PythonSearchByLowerCaseScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity} where
    python.LocalNameLowerCase { NameStr, python.LocalName Name };
    Insensitive = true;
    PythonSearchByScopeWithName { Name, Insensitive, Query, Entity }

# Private: search by scope anchored on a local_name fact
predicate PythonSearchByScopeWithName:
  {
    name: string,
    insensitive : bool,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Insensitive, Scope, Entity } where
    search.python.QueryToScopeCase { Scope, Insensitive, MSName };
    Name = python.Name NameStr; # tickle the optimizer to do this second
    SName = python.SName { Name, MSName };
    python.DeclarationWithSName { SName, Decl };
    python.NonImportDeclaration Decl;
    { python = { decl = Decl } } = Entity;

predicate PythonSearchByLowerCaseNameKindAndScopeFact:
  {
    name: string,
    scope: maybe python.SName,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity
  }
  { NameStr, Scope, Kinds, Entity } where
    PythonNameLowerCase { NameStr, Kinds, Name };
    PythonSearchByNameKindAndScopeFact { Name, Scope, Kinds, Entity }

# with a bare string name and a known scope, search by kind
predicate PythonSearchByNameKindAndScopeFact:
  {
    name: string,
    scope: maybe python.SName,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity
  }
  { NameStr, Scope, Kinds, Entity } where
    # n.b no un-kinded entities in Python, so we ignore the `nothing` case
    { just = Kind } = Kinds;
    (
      Class_ = Kind;
      python.SearchClassByName { NameStr, Scope, CDecl };
      { cls = CDecl } = Decl
    ) | (
      Module = Kind;
      python.SearchModuleByName { NameStr, Scope, MDecl };
      { module = MDecl } = Decl
    ) | (
      Function = Kind;
      python.SearchFunctionByName { NameStr, Scope, FDecl };
      { func = FDecl } = Decl
    ) | (
      Method = Kind;
      python.SearchMethodByName { NameStr, Scope, MDecl };
      { func = MDecl } = Decl
    ) | (
      Field = Kind;
      python.SearchFieldByName { NameStr, Scope, FDecl };
      { variable = FDecl } = Decl
    ) | (
      Variable = Kind;
      python.SearchVariableByName { NameStr, Scope, VDecl };
      { variable = VDecl } = Decl
    );
    { python = { decl = Decl } } = Entity

# Maps lower-case strings to normal Names, for case-insensitive search
predicate PythonNameLowerCase :
  {
    nameLowercase : string,
    kinds: maybe codemarkup.types.SymbolKind,
    name : string,
  }
  { NameLower, Kinds, Name } where
    { just = Kind } = Kinds;
    ( Class_ = Kind;
      python.SearchClassByLowerCaseName { NameLower, Name }
    ) | (
      Module = Kind;
      python.SearchModuleByLowerCaseName { NameLower, Name }
    ) | (
      Function = Kind;
      python.SearchFunctionByLowerCaseName { NameLower, Name }
    ) | (
      Method = Kind;
      python.SearchMethodByLowerCaseName { NameLower, Name };
    ) | (
      Field = Kind;
      python.SearchFieldByLowerCaseName { NameLower, Name }
    ) | (
      Variable = Kind;
      python.SearchVariableByLowerCaseName { NameLower, Name }
    );


predicate FlowSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    ( Name = flow.Name NameStr;
      FlowSearchByNameWithFact { Name, Entity }
    ) | (
      flow.SearchByModuleName { NameStr, Mod };
      { flow = { module_ = Mod } } = Entity
    )

predicate FlowSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    ( flow.NameLowerCase { NameStr, Name };
      FlowSearchByNameWithFact { Name, Entity }
    ) | (
      flow.ModuleNameLowerCase { NameStr, Mod };
      { flow = { module_ = Mod } } = Entity
    )

# helper to share Name fact in the lower case scenario
#
# Similar to C++ and Python, we don't include import declarations
# in search results, as they are too noisy
#
predicate FlowSearchByNameWithFact:
  {
    name: flow.Name,
    entity: code.Entity
  }
  { Name, { flow = { decl = Decl } } } where
    search.flow.FlowSearchByNameNonImport { Name, Decl };

# Flow scope search: just parent module -> decl pairs for now
predicate FlowSearchByScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity } where
    Name = flow.Name NameStr;
    Insensitive = false;
    FlowSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate FlowSearchByLowerCaseScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity } where
    flow.NameLowerCase { NameStr, Name };
    Insensitive = true;
    FlowSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate FlowSearchByScopeWithName:
  {
    name: flow.Name,
    insensitive : bool,
    scope: [string],
    entity: code.Entity,
  }
  { Name, Insensitive, Query, Entity } where
    search.flow.QueryToScopeCase { Query, Insensitive, Scope };
    { just = Module } = Scope; # every decl is contained in something?
    search.flow.FlowSearchByNameNonImport { Name, Decl };
    flow.ModuleContains { Module, Decl }; # filter on membership
    { flow = { decl = Decl } } = Entity;

predicate JavaSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    Name = javakotlin.alpha.Name NameStr;
    QName = javakotlin.alpha.QName { name = Name };
    JavaSearchByNameWithFact { QName, Entity }

predicate JavaSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    javakotlin.alpha.NameLowerCase { NameStr, Name };
    QName = javakotlin.alpha.QName { name = Name };
    JavaSearchByNameWithFact { QName, Entity }

predicate JavaSearchByNameWithFact:
  {
    name: javakotlin.alpha.QName,
    entity: code.Entity
  }
  { QName, { java = { decl = Decl } } } where
    search.java.SearchByQName { QName, Decl };

predicate JavaSearchByScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity
  }
  { NameStr, Query, Entity } where
    Name = javakotlin.alpha.Name NameStr;
    Insensitive = false;
    JavaSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate JavaSearchByLowerCaseScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity } where
    javakotlin.alpha.NameLowerCase { NameStr, Name };
    Insensitive = true;
    JavaSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate JavaSearchByScopeWithName:
  {
    name: javakotlin.alpha.Name,
    insensitive : bool,
    scope: [string],
    entity: code.Entity,
  }
  { Name, Insensitive, Query, Entity } where
    search.java.QueryToScopeCase { Query, Insensitive, Path };
    QName = javakotlin.alpha.QName { name = Name, context = Path };
    search.java.SearchByQName { QName, Decl };
    { java = { decl = Decl } } = Entity;

predicate KotlinSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    Name = javakotlin.alpha.Name NameStr;
    QName = javakotlin.alpha.QName { name = Name };
    KotlinSearchByNameWithFact { QName, Entity }

predicate KotlinSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    javakotlin.alpha.NameLowerCase { NameStr, Name };
    QName = javakotlin.alpha.QName { name = Name };
    KotlinSearchByNameWithFact { QName, Entity }

predicate KotlinSearchByNameWithFact:
  {
    name: javakotlin.alpha.QName,
    entity: code.Entity
  }
  { QName, { kotlin = { decl = Decl } } } where
    search.kotlin.SearchByQName { QName, Decl };

predicate KotlinSearchByScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity
  }
  { NameStr, Query, Entity } where
    Name = javakotlin.alpha.Name NameStr;
    Insensitive = false;
    KotlinSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate KotlinSearchByLowerCaseScope:
  {
    name: string,
    scope: [string],
    entity: code.Entity,
  }
  { NameStr, Query, Entity } where
    javakotlin.alpha.NameLowerCase { NameStr, Name };
    Insensitive = true;
    KotlinSearchByScopeWithName { Name, Insensitive, Query, Entity }

predicate KotlinSearchByScopeWithName:
  {
    name: javakotlin.alpha.Name,
    insensitive : bool,
    scope: [string],
    entity: code.Entity,
  }
  { Name, Insensitive, Query, Entity } where
    search.java.QueryToScopeCase { Query, Insensitive, Path }; # n.b. java
    QName = javakotlin.alpha.QName { name = Name, context = Path };
    search.kotlin.SearchByQName { QName, Decl };
    { kotlin = { decl = Decl } } = Entity;

predicate CSharpSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    Name = csharp.Name NameStr;
    csharp.SearchByName { Name, Defn };
    { csharp = { decl = Defn } } = Entity

predicate CSharpSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    csharp.NameLowerCase { NameStr, Name };
    csharp.SearchByName { Name, Defn };
    { csharp = { decl = Defn } } = Entity

predicate CxxSearchByScopeAndKind:
  {
    name: string,
    scope: [string],
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity,
  }
  { NameStr, Query, Kinds, Entity } where
    search.cxx.QueryToScopeCase { Query, false, Scope };
    CxxSearchByNameKindAndScopeFact { NameStr, Scope, Kinds, Entity }

predicate CxxSearchByLowerCaseScopeAndKind:
  {
    name: string,
    scope: [string],
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity,
  }
  { NameStr, Query, Kinds, Entity } where
    search.cxx.QueryToScopeCase { Query, true, Scope };
    CxxSearchByLowerCaseNameKindAndScopeFact { NameStr, Scope, Kinds, Entity };

# with a bare string name and a known scope, search by kind
predicate CxxSearchByNameKindAndScopeFact:
  {
    name: string,
    scope : cxx1.Scope,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity
  }
  { NameStr, Scope, Kinds, Entity } where
    # n.b no un-kinded entities in C++, so we ignore the `nothing` case
    { just = Kind } = Kinds;
    (
      Namespace = Kind;
      search.kind.cxx.SearchNamespace { NameStr, Scope, Ent };
    ) | (
      Class_ = Kind;
      search.kind.cxx.SearchClass { NameStr, Scope, Ent };
    ) | (
      Struct = Kind;
      search.kind.cxx.SearchStruct { NameStr, Scope, Ent };
    ) | (
      Union = Kind;
      search.kind.cxx.SearchUnion { NameStr, Scope, Ent };
    ) | (
      Enum_ = Kind;
      search.kind.cxx.SearchEnum { NameStr, Scope, Ent };
    ) | (
      Function = Kind;
      search.kind.cxx.SearchFunction { NameStr, Scope, Ent };
    ) | (
      Variable = Kind;
      search.kind.cxx.SearchVariable { NameStr, Scope, Ent };
    ) | (
      Enumerator = Kind;
      search.kind.cxx.SearchEnumerator { NameStr, Scope, Ent };
    ) | (
      Type = Kind; # type alias or using decl is a "Type" kind
      search.kind.cxx.SearchTypeAlias { NameStr, Scope, Ent };
    ) | (
      Interface = Kind;
      { global_ = {} } = Scope; # objc containers have global scope
      search.kind.cxx.SearchObjcInterface { NameStr, Ent };
    );
    CxxPreferDefinitions { Ent, OutEnt };
    { cxx = OutEnt } = Entity;

# lower case form. names are normalized through cxx1.DeclByName
predicate CxxSearchByLowerCaseNameKindAndScopeFact:
  {
    name: string,
    scope : cxx1.Scope,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity
  }
  { NameStr, Scope, Kinds, Entity } where
    cxx1.NameLowerCase { NameStr, NameNormal };
    CxxSearchByNameKindAndScopeFact { NameNormal, Scope, Kinds, Entity }

# Helper for C++ to prefer definitions over declaration spam
predicate CxxPreferDefinitions:
  { from: code.cxx.Entity
  , to : code.cxx.Entity
  }
  { InEnt, OutEnt } where
    if ({ decl = Decl } = InEnt)
      then (
        # avoid returning all members of decl families
        if (search.cxx.DeclIsDefn { Decl, Defn })
          then ({ defn = Defn } = OutEnt)
          else ({ decl = Decl } = OutEnt)
        )
      else ( InEnt = OutEnt ); # already a defn (or enumerator)

predicate PpSearchByNameKind:
  {
    name: string,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity
  }
  { NameStr, Kinds, { pp = { define = Define } } } where
    { just = Macro } = Kinds; # this avoids unnecessary #define searches
    pp1.Macro NameStr = Macro;
    pp1.Define { macro = Macro } = Define

# n.b. this reuses the stored, derived lower case pp1.Macro in cxx1.DeclByName
predicate PpSearchByLowerCaseNameKind:
  {
    name: string,
    kinds: maybe codemarkup.types.SymbolKind,
    entity: code.Entity
  }
  { NameStr, Kinds, { pp = { define = Define } } } where
    { just = Macro } = Kinds; # this avoids unnecessary #define searches
    pp1.DefineLowerCase { NameStr, Define }

predicate ThriftSearchByName:
  {
    name: string,
    entity: code.Entity
  }
  { Name, Entity } where
    ( Ident = fbthrift.Identifier Name;
      FbthriftSearchByNameFact { Ident, Entity } )

predicate ThriftSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity
  }
  { NameStr, Entity } where
    ( fbthrift.NameLowerCase { NameStr, Ident };
      FbthriftSearchByNameFact { Ident, Entity } )

predicate FbthriftSearchByNameFact:
  {
    name: fbthrift.Identifier,
    entity: code.Entity
  }
  { Ident, { fbthrift = { decl = Decl } }} where
    fbthrift.SearchByName { Ident, QName };
    fbthrift.DeclarationName { QName, Decl }

predicate BuckSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    LocalName = buck.LocalName NameStr;
    BuckSearchByLocalNameFact { LocalName, Entity }

predicate BuckSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    buck.LocalNameLowerCase { NameStr, LocalName };
    BuckSearchByLocalNameFact { LocalName, Entity }

# helper to avoid repeatedly doing string search
predicate BuckSearchByLocalNameFact:
  {
    name: buck.LocalName,
    entity: code.Entity,
  }
  { LocalName, { buck = Decl }} where
    buck.SearchByLocalName { LocalName, Decl }

predicate HsSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, { hs = E } } where
  search.hs.SearchByName { name = Name, entity = E }

predicate HsSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, Entity } where
  (
    hs.ModuleNameLowerCase { Name, hs.ModuleName NameCase } |
    hs.FunctionNameLowerCase { Name, hs.FunctionName NameCase } |
    hs.DefinitionNameLowerCase { Name, hs.DefinitionName NameCase } |
    hs.ClassNameLowerCase { Name, hs.ClassName NameCase }
  );
  HsSearchByName { NameCase, Entity };

predicate ErlangSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, { erlang = E } } where
  search.erlang.SearchByName { name = Name, entity = E }

predicate ErlangSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, Entity } where
  erlang.NameLowerCase { Name, NameCase };
  ErlangSearchByName { NameCase, Entity }

predicate LsifSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, { lsif = Entity } } where
  lsif.SearchByName { lsif.Name Name, Entity }

predicate LsifSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { Name, { lsif = Entity } } where
  lsif.NameLowerCase { Name, NameCase };
  lsif.SearchByName { NameCase, Entity }

predicate GraphQLSearchByName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    Name = graphql.Value NameStr;
    graphql.SearchByName { Name, Decl };
    { graphql = { decl = Decl } } = Entity

predicate GraphQLSearchByLowerCaseName:
  {
    name: string,
    entity: code.Entity,
  }
  { NameStr, Entity } where
    graphql.NameLowerCase { NameStr, Name };
    graphql.SearchByName { Name, Decl };
    { graphql = { decl = Decl } } = Entity

}
